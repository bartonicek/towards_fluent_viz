\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{2}{section.1}\protected@file@percent }
\newlabel{introduction}{{1}{2}{Introduction}{section.1}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Brief history of static data visualization}{2}{subsection.1.1}\protected@file@percent }
\newlabel{brief-history-of-static-data-visualization}{{1.1}{2}{Brief history of static data visualization}{subsection.1.1}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}Early interactive data visualization}{2}{subsection.1.2}\protected@file@percent }
\newlabel{early-interactive-data-visualization}{{1.2}{2}{Early interactive data visualization}{subsection.1.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3}Web-native interactivity}{3}{subsection.1.3}\protected@file@percent }
\newlabel{web-native-interactivity}{{1.3}{3}{Web-native interactivity}{subsection.1.3}{}}
\@writefile{toc}{\contentsline {section}{\numberline {2}What do we interact with?}{4}{section.2}\protected@file@percent }
\newlabel{what-do-we-interact-with}{{2}{4}{What do we interact with?}{section.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Rough sketch of the data visualization process}{4}{subsection.2.1}\protected@file@percent }
\newlabel{rough-sketch-of-the-data-visualization-process}{{2.1}{4}{Rough sketch of the data visualization process}{subsection.2.1}{}}
\newlabel{eq:recipe1}{{1}{5}{Rough sketch of the data visualization process}{equation.2.1}{}}
\newlabel{eq:recipe2}{{2}{5}{Rough sketch of the data visualization process}{equation.2.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Summaries as first-class citizens}{6}{subsection.2.2}\protected@file@percent }
\newlabel{summaries-as-first-class-citizens}{{2.2}{6}{Summaries as first-class citizens}{subsection.2.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}A couple of caveats}{6}{subsection.2.3}\protected@file@percent }
\newlabel{a-couple-of-caveats}{{2.3}{6}{A couple of caveats}{subsection.2.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Histogram and spineplot use the same summaries but encode them in different ways. a) In histogram, the x-axis display bin breaks and y-axis displays count, stacked across groups (failure/no failure). b) In spineplot, the x-axis and y-axis both display count; the x-axis shows count stacked across bins, whereas the y-axis shows count stacked across groups and scaled by the total bin count (such that the total bin height = 1). The bin breaks are displayed as x-axis labels (however, the underlying summary is still stacked count).}}{7}{figure.1}\protected@file@percent }
\newlabel{fig:histospine}{{1}{7}{Histogram and spineplot use the same summaries but encode them in different ways. a) In histogram, the x-axis display bin breaks and y-axis displays count, stacked across groups (failure/no failure). b) In spineplot, the x-axis and y-axis both display count; the x-axis shows count stacked across bins, whereas the y-axis shows count stacked across groups and scaled by the total bin count (such that the total bin height = 1). The bin breaks are displayed as x-axis labels (however, the underlying summary is still stacked count)}{figure.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Interactivity and Hierarchy}{7}{section.3}\protected@file@percent }
\newlabel{interactivity-and-hierarchy}{{3}{7}{Interactivity and Hierarchy}{section.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Reactive hierarchy in a stacked histogram. When selection changes (as a result of linked brushing), we do not need to recompute bins, since these depend just on the data, anchor, and binwidth (= parent nodes). Instead, we only need to recompute count within each sub-bar, defined by combinations of bin and group. However, when either anchor or binwidth change, we do need to recompute the bins, and as a result counts as well (= child nodes).}}{8}{figure.2}\protected@file@percent }
\newlabel{fig:hierarchy}{{2}{8}{Reactive hierarchy in a stacked histogram. When selection changes (as a result of linked brushing), we do not need to recompute bins, since these depend just on the data, anchor, and binwidth (= parent nodes). Instead, we only need to recompute count within each sub-bar, defined by combinations of bin and group. However, when either anchor or binwidth change, we do need to recompute the bins, and as a result counts as well (= child nodes)}{figure.2}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4}The Problem of Statistical Summaries}{9}{section.4}\protected@file@percent }
\newlabel{the-problem-of-statistical-summaries}{{4}{9}{The Problem of Statistical Summaries}{section.4}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Case study: Counts and Means}{9}{subsection.4.1}\protected@file@percent }
\newlabel{case-study-counts-and-means}{{4.1}{9}{Case study: Counts and Means}{subsection.4.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces The problem of representing empty selection. a) An illustration of selection by linked brushing. b) In the barplot of counts, the count within an empty selection (red) is zero and so an absence of a bar accurately represents a count of zero. c) In the barplot of means, the mean of an empty selection is not defined. Absence of a bar could indicate that either no cases are selected or some cases are selected and their mean is equal to the lower y-axis limit (zero in this case).}}{9}{figure.3}\protected@file@percent }
\newlabel{fig:empty}{{3}{9}{The problem of representing empty selection. a) An illustration of selection by linked brushing. b) In the barplot of counts, the count within an empty selection (red) is zero and so an absence of a bar accurately represents a count of zero. c) In the barplot of means, the mean of an empty selection is not defined. Absence of a bar could indicate that either no cases are selected or some cases are selected and their mean is equal to the lower y-axis limit (zero in this case)}{figure.3}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2}Empty selections}{9}{subsection.4.2}\protected@file@percent }
\newlabel{empty-selections}{{4.2}{9}{Empty selections}{subsection.4.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces The relationship between selection vs.\nobreakspace  {}the whole. a) An illustration of selection by linked brushing. b) In the barplot of counts (middle), the count within a selection (red) is always less than or equal to the count within the whole and the outline of the bars does not change. c) In the barplot of means, the mean of a selection can be greater and so the outline of the bars will change in response to user input.}}{10}{figure.4}\protected@file@percent }
\newlabel{fig:bigger}{{4}{10}{The relationship between selection vs.~the whole. a) An illustration of selection by linked brushing. b) In the barplot of counts (middle), the count within a selection (red) is always less than or equal to the count within the whole and the outline of the bars does not change. c) In the barplot of means, the mean of a selection can be greater and so the outline of the bars will change in response to user input}{figure.4}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.3}Part vs.\nobreakspace  {}the whole}{10}{subsection.4.3}\protected@file@percent }
\newlabel{part-vs.-the-whole}{{4.3}{10}{Part vs.~the whole}{subsection.4.3}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.4}Combining parts}{11}{subsection.4.4}\protected@file@percent }
\newlabel{combining-parts}{{4.4}{11}{Combining parts}{subsection.4.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Combining selections. a) An illustration of selection by linked brushing, with two groups. b) In the barplot of counts, statistics can be stacked on top of each other such that the count of the stacked bar is identical to the count of the whole bar (i.e.\nobreakspace  {}one that would result from no selections). c) In the barplot of means, no such procedure for combining statistics exists.}}{11}{figure.5}\protected@file@percent }
\newlabel{fig:stacking}{{5}{11}{Combining selections. a) An illustration of selection by linked brushing, with two groups. b) In the barplot of counts, statistics can be stacked on top of each other such that the count of the stacked bar is identical to the count of the whole bar (i.e.~one that would result from no selections). c) In the barplot of means, no such procedure for combining statistics exists}{figure.5}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.5}Some statistics are better than others}{11}{subsection.4.5}\protected@file@percent }
\newlabel{some-statistics-are-better-than-others}{{4.5}{11}{Some statistics are better than others}{subsection.4.5}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Few Relevant Bits of Category Theory}{12}{section.5}\protected@file@percent }
\newlabel{few-relevant-bits-of-category-theory}{{5}{12}{Few Relevant Bits of Category Theory}{section.5}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1}Functions}{12}{subsection.5.1}\protected@file@percent }
\newlabel{functions}{{5.1}{12}{Functions}{subsection.5.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Two types of functions: a) surjective, b) injective.}}{13}{figure.6}\protected@file@percent }
\newlabel{fig:functions}{{6}{13}{Two types of functions: a) surjective, b) injective}{figure.6}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.2}Partitions}{13}{subsection.5.2}\protected@file@percent }
\newlabel{partitions}{{5.2}{13}{Partitions}{subsection.5.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3}Preorders}{13}{subsection.5.3}\protected@file@percent }
\newlabel{preorders}{{5.3}{13}{Preorders}{subsection.5.3}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4}Monoids}{14}{subsection.5.4}\protected@file@percent }
\newlabel{monoids}{{5.4}{14}{Monoids}{subsection.5.4}{}}
\@writefile{toc}{\contentsline {section}{\numberline {6}Outline of the Model}{15}{section.6}\protected@file@percent }
\newlabel{outline-of-the-model}{{6}{15}{Outline of the Model}{section.6}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1}Data and partitions}{15}{subsection.6.1}\protected@file@percent }
\newlabel{data-and-partitions}{{6.1}{15}{Data and partitions}{subsection.6.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Three ways of partitioning a tabular data set. a) The underlying data, represented as a matrix with 3 rows and 2 columns. b) To draw a scatterplot, we can slice along the rows and draw points at the x- and y-position given by the columns. c) To draw a lineplot, we can slice along the columns \& draw lines by connecting points given by the corresponding row values. d) To draw a dotplot, we can slice along both rows and columns and draw points at given row and column index, with point size given by the corresponding cell value.}}{16}{figure.7}\protected@file@percent }
\newlabel{fig:partitioning}{{7}{16}{Three ways of partitioning a tabular data set. a) The underlying data, represented as a matrix with 3 rows and 2 columns. b) To draw a scatterplot, we can slice along the rows and draw points at the x- and y-position given by the columns. c) To draw a lineplot, we can slice along the columns \& draw lines by connecting points given by the corresponding row values. d) To draw a dotplot, we can slice along both rows and columns and draw points at given row and column index, with point size given by the corresponding cell value}{figure.7}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2}Computing Statistics}{18}{subsection.6.2}\protected@file@percent }
\newlabel{computing-statistics}{{6.2}{18}{Computing Statistics}{subsection.6.2}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.1}Reduce}{18}{subsubsection.6.2.1}\protected@file@percent }
\newlabel{reduce}{{6.2.1}{18}{Reduce}{subsubsection.6.2.1}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.2}Map and Stack}{18}{subsubsection.6.2.2}\protected@file@percent }
\newlabel{map-and-stack}{{6.2.2}{18}{Map and Stack}{subsubsection.6.2.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Diagram of the reduce operation: we iterate through \(n\) datapoints, updating the appropriate collection of summaries (one of \(k\), ) at each step.}}{19}{figure.8}\protected@file@percent }
\newlabel{fig:unnamed-chunk-2}{{8}{19}{Diagram of the reduce operation: we iterate through \(n\) datapoints, updating the appropriate collection of summaries (one of \(k\), ) at each step}{figure.8}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Diagram of the map operation: we iterate through the \(k\) collections of summaries, translating each collection at each step.}}{19}{figure.9}\protected@file@percent }
\newlabel{fig:unnamed-chunk-3}{{9}{19}{Diagram of the map operation: we iterate through the \(k\) collections of summaries, translating each collection at each step}{figure.9}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Diagram of stacking: we iterate through the \(k\) collections of summaries, each time first updating the collection of stacked values (belonging to the appropriate parent part) by the part values and then copying the stacked values into the part.}}{20}{figure.10}\protected@file@percent }
\newlabel{fig:unnamed-chunk-4}{{10}{20}{Diagram of stacking: we iterate through the \(k\) collections of summaries, each time first updating the collection of stacked values (belonging to the appropriate parent part) by the part values and then copying the stacked values into the part}{figure.10}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces Illustration of the model structure. Data is split into a hierarchy of partitions (left). Parts within partitions form a graph/tree that can be used to calculate summaries/statistics (middle). Finally, the hierarchy of summaries is plotted via geometric objects (right).}}{21}{figure.11}\protected@file@percent }
\newlabel{fig:process}{{11}{21}{Illustration of the model structure. Data is split into a hierarchy of partitions (left). Parts within partitions form a graph/tree that can be used to calculate summaries/statistics (middle). Finally, the hierarchy of summaries is plotted via geometric objects (right)}{figure.11}{}}
\newlabel{references}{{6.2.2}{22}{References}{section*.2}{}}
\@writefile{toc}{\contentsline {section}{References}{22}{section*.2}\protected@file@percent }
\gdef \@abspage@last{23}
